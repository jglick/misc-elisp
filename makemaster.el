;;; $Id: makemaster.el 1.3 Sun, 06 Dec 1998 00:53:07 +0100 dude $

;; Special mode to show makefiles and their targets,
;; incl. up-to-date-edness, and allowing displayed targets to be made.

;; Usage in .emacs:
;; (autoload 'makemaster "makemaster" "Makefile target browsing/running mode." t)

;; XXX should be redesigned so that all make invocations are fully
;; asynch (& can be parallelized, even)

;; XXX free var `makefiles'

(message "Loading makemaster...")
(require 'cl)

(defvar makemaster-initial-makefiles nil
  "*List of lists. Each sublist must have as its first element the
*complete* path to a makefile, including the name of the makefile
itself; second, a list of queryable targets; third, a list of
nonqueryable targets. These makefiles and targets will be displayed
when Makemaster-mode starts.")

(defvar makemaster-buffer-name "*Make-Master*")

(defvar makemaster-make-program "make"
  "*Make program that will handle `-q'. Preferably GNU make.")

(defvar makemaster-mode-map nil)
(when (not makemaster-mode-map)
  (setq makemaster-mode-map (make-keymap))
  (do ((i 32 (+ i 1)))
      ((= i 127) nil)
    (define-key makemaster-mode-map (char-to-string i) 'undefined))
  (define-key makemaster-mode-map "\C-j" 'undefined)
  (define-key makemaster-mode-map "\C-m" 'undefined)
  (define-key makemaster-mode-map "h" 'describe-mode)
  (define-key makemaster-mode-map "?" 'makemaster-refresh-single)
  (define-key makemaster-mode-map "g" 'makemaster-refresh)
  (define-key makemaster-mode-map "v" 'makemaster-visit)
  (define-key makemaster-mode-map "m" 'makemaster-make)
  (define-key makemaster-mode-map "M" 'makemaster-make-with-flags)
  (define-key makemaster-mode-map " " 'makemaster-down-target)
  (define-key makemaster-mode-map "n" 'makemaster-down-target)
  (define-key makemaster-mode-map "\C-?" 'makemaster-up-target)
  (define-key makemaster-mode-map "p" 'makemaster-up-target)
  (define-key makemaster-mode-map "N" 'makemaster-down-makefile)
  (define-key makemaster-mode-map "P" 'makemaster-up-makefile)
  (define-key makemaster-mode-map "a" 'makemaster-add-target)
  (define-key makemaster-mode-map "A" 'makemaster-add-makefile)
  (define-key makemaster-mode-map "d" 'makemaster-delete-target)
  (define-key makemaster-mode-map "D" 'makemaster-delete-makefile))

(defvar makemaster-output-divider "\n<<<--- Make output --->>>\n\n"
  "*Text dividing display area from output area in a Make-Master
buffer.")

(defun makemaster-mode nil
  "Major mode to look at makefiles and their targets, see which ones
need making, and optionally do so.

Names of makefiles are placed flush with the left margin; beneath them
and indented are the names of targets in those makefiles, preceded by
`+' or `-' according as they are up-to-date or not, respectively.

Some targets, marked with an initial `?', are not queryable, although
they can still be made: some makefiles can have trouble querying
certain things correctly, and for targets like `clean' there is no
point.

After a divider, the rest of the buffer displays output generated by
`make' in making targets, as well as that generated when there is an
error during a query.

\\<makemaster-mode-map>
\\[makemaster-add-makefile] adds a new makefile.
\\[makemaster-add-target] adds a new target to that makefile.
\\[makemaster-delete-makefile] deletes the makefile entry under point.
\\[makemaster-delete-target] deletes the target entry under point.
\\[makemaster-down-target] and \\[makemaster-up-target] scroll through targets;
\\[makemaster-down-makefile] and \\[makemaster-up-makefile] do similarly for makefiles.
\\[makemaster-make] makes the target under point, after asking confirmation;
\\[makemaster-make-with-flags] does the same but prompts for `make' flags.
\\[makemaster-refresh-single] updates the display for the makefile at point;
\\[makemaster-refresh] updates the entire display and clears the output lines.
\\[makemaster-visit] visits makefile at point.
\\[describe-mode] gives this help.

List of all commands:
\\{makemaster-mode-map}

Customizable variables:
`makemaster-initial-targets'

Will run `makemaster-mode-hook'."
  (kill-all-local-variables)
  (setq major-mode 'makemaster-mode)
  (setq mode-name "Make Master")
  (use-local-map makemaster-mode-map)
  (make-local-variable 'makefiles)
  (setq makefiles (copy-tree makemaster-initial-makefiles))
  (put 'makemaster-mode 'mode-class 'special)
  (run-hooks 'makemaster-mode-hook))

(defun makemaster nil
  "Start `makemaster-mode', q.v."
  (interactive)
  (let ((veteran (get-buffer makemaster-buffer-name)))
    (switch-to-buffer makemaster-buffer-name)
    (when (not veteran)
      (makemaster-mode)
      (insert makemaster-output-divider)
      (makemaster-refresh))
    (message "Type `h' for help.")))

(defun makemaster-visit nil
  "Visit makefile at point."
  (interactive)
  (let ((makefile (car (makemaster-where-am-i))))
    (find-file-other-window makefile)))

(defun makemaster-refresh nil
  "Refresh entire Make-master display. Will clear existing \"make\"
output display."
  (interactive)
  (erase-buffer)
  (goto-char (point-min))
  (insert makemaster-output-divider)
  (goto-char (point-min))
  (dolist (entry makefiles)
    (insert (car entry) "\n")
    (dolist (target (cadr entry))
      (insert "\t" (if (makemaster-query target (car entry)) "- " "+ ") target "\n"))
    (dolist (target (caddr entry))
      (insert "\t? " target "\n")))
  (goto-char (point-min))
  (not-modified)
  (message nil))

(defun makemaster-refresh-single nil
  "Refresh a single makefile."
  (interactive)
  (let ((makefile (car (makemaster-where-am-i))))
    (if makefile
	(makemaster-refresh-makefile makefile)
      (error "No makefile found at point"))))

(defun makemaster-make nil
  "Make target at point, with confirmation."
  (interactive)
  (let* ((wai (makemaster-where-am-i))
	 (makefile (car wai))
	 (target (cdr wai)))
    (if (not target)
	(error "Not near a target"))
    (when (yes-or-no-p (concat "Make `" target "' on `" makefile "'? "))
      (makemaster-run target makefile)
      (makemaster-refresh-makefile makefile))))

(defun makemaster-make-with-flags nil
  "Make target at point, with confirmation. Prompt for extra flags."
  (interactive)
  (let* ((wai (makemaster-where-am-i))
	 (makefile (car wai))
	 (target (cdr wai)))
    (if (not target)
	(error "Not near a target"))
    (let ((flagsstring (read-string "Flags: "))
	  (flags nil)
	  (flagpos 0))
      (while (string-match "[^ ]+" flagsstring flagpos)
	(setq flags (nconc flags (list (match-string 0 flagsstring))))
	(setq flagpos (match-end 0)))
      (when (yes-or-no-p (concat "Make `" target "' on `" makefile "' with flags"
				 (makemaster-join-flags flags) "? "))
	(makemaster-run target makefile flags)
	(makemaster-refresh-makefile makefile)))))

(defun makemaster-add-target (target)
  "Add a new target to makefile at point."
  (interactive "sTarget name: ")
  (let ((makefile (car (makemaster-where-am-i)))
	(qable (y-or-n-p "Queryable target? "))) 
    (if (not makefile) (error "No makefile at point"))
    (push target (nth (if qable 1 2)
		      (find makefile makefiles :key 'car :test 'string-equal)))
    (makemaster-goto-makefile makefile)
    (next-line 1)
    (insert "\t" (if qable (if (makemaster-query target makefile) "- " "+ ") "? ")
	    target "\n")
    (previous-line 1))
  (not-modified)
  (message nil))

(defun makemaster-add-makefile (makefile)
  "Add a new makefile."
  (interactive "fMakefile name: ")
  (setq makefile (expand-file-name makefile))
  (setq makefiles (nconc makefiles (list (list makefile))))
  (goto-char (makemaster-find-end))
  (insert makefile "\n")
  (previous-line 1)
  (not-modified)
  (message nil))

(defun makemaster-delete-target nil
  "Delete target at point."
  (interactive)
  (let* ((wai (makemaster-where-am-i))
	 (makefile (car wai))
	 (target (cdr wai))
	 entry)
    (if (not target) (error "No target at point"))
    (setq entry (find makefile makefiles :key 'car :test 'string-equal))
    (setf (cadr entry) (delete* target (cadr entry) :test 'string-equal))
    (setf (caddr entry) (delete* target (caddr entry) :test 'string-equal))
    (makemaster-goto-target target makefile)
    (kill-line 1)
    (previous-line 1))
  (not-modified)
  (message nil))

(defun makemaster-delete-makefile nil
  "Delete makefile at point."
  (interactive)
  (let ((makefile (car (makemaster-where-am-i))))
    (if (not makefile) (error "No makefile at point"))
    (setq makefiles (delete* makefile makefiles :key 'car :test 'string-equal))
    (makemaster-goto-makefile makefile)
    (kill-line 1)
    (while (looking-at "^\t")
      (kill-line 1)))
  (not-modified)
  (message nil))

(defun makemaster-up-target nil
  "Move up one target."
  (interactive)
  (beginning-of-line)
  (re-search-backward "^\t" nil 'limit))

(defun makemaster-down-target nil
  "Move down one target."
  (interactive)
  (end-of-line)
  (re-search-forward "^\t" (makemaster-find-end) 'limit)
  (beginning-of-line))

(defun makemaster-up-makefile nil
  "Move up one makefile."
  (interactive)
  (beginning-of-line)
  (re-search-backward "^[^\t]" nil 'limit))

(defun makemaster-down-makefile nil
  "Move down one makefile."
  (interactive)
  (end-of-line)
  (re-search-forward "^[^\t]" (makemaster-find-end) 'limit)
  (beginning-of-line))

(defun makemaster-query (target filename)
  "Query a makefile for up-to-datedness of a target. Handles GNU make;
arbitrarily named makefile in any dir; erroneous output is displayed;
checks for errors."
  (message "Querying `%s' for target `%s'..." filename target)
  (save-excursion
    (makemaster-goto-output-area)
    (insert "*** Querying `" target "' on `" filename "' ***\n\n\n")
    (backward-char 2)
    (let* ((file (file-name-nondirectory filename))
	   (dir (file-name-directory filename))
	   (status (call-process makemaster-make-program nil '(t t) t
				 "-C" dir "-f" file "-q" target)))
      (if (= status 2)
	  (error "Couldn't query makefile `%s' for target `%s'" filename target))
      ;; Assume no output and remove unused querying message
      (previous-line 1)
      (kill-line 3)
      (not-modified)
      (message "Querying `%s' for target `%s'...done" filename target)
      (not (zerop status)))))

(defun makemaster-join-flags (flags)
  "Join together args (strings) with space before each."
  (apply 'concat (mapcar (lambda (x) (concat " " x)) flags)))

(defun makemaster-run (target filename &optional flags)
  "Make the given target. May be passed a list of extra flags."
  (let ((with-string
	 (if (not flags) "" (concat " with" (makemaster-join-flags flags)))))
    (message "Running `%s' on `%s'%s..." target filename with-string)
    (let* ((file (file-name-nondirectory filename))
	   (dir (file-name-directory filename))
	   (status (save-excursion
		     (makemaster-goto-output-area)
		     (insert "*** `" target "' on `" filename "'"
			     with-string " ***\n\n")
		     (backward-char 1)
		     (apply 'call-process makemaster-make-program nil '(t t) t
			    (append flags (list "-C" dir "-f" file target))))))
      (if (= status 2)
	  (error "Couldn't run makefile `%s' on target `%s'%s"
		 filename target with-string)))
    (not-modified)
    (message "Running `%s' on `%s'%s...done" target filename with-string)))

(defun makemaster-refresh-makefile (makefile)
  "Refresh a given makefile display only."
  (save-excursion
    (makemaster-goto-makefile makefile)
    (next-line 1)
    (while (looking-at "\t\\([+-?]\\) \\(.*\\)\n")
      (let ((target (match-string 2))
	    (endpos (match-end 0))
	    (prefix (match-string 1)))
	(goto-char (match-beginning 1))
	(delete-char 1)
	(insert (if (string-equal prefix "?") "?"
		  (if (makemaster-query target makefile) "-" "+")))
	(goto-char endpos))))
  (not-modified)
  (message nil))

(defun makemaster-goto-makefile (makefile)
  "Go to a makefile line."
  (goto-char (point-min))
  (search-forward (concat makefile "\n") (makemaster-find-end))
  (previous-line 1))

(defun makemaster-goto-target (target makefile)
  "Go to a target line."
  (makemaster-goto-makefile makefile)
  (re-search-forward (concat "\t[+-?] " target "\n"))
  (previous-line 1))

(defun makemaster-goto-output-area nil
  "Go to the beginning of the output area."
  (goto-char (point-min))
  (search-forward makemaster-output-divider))

(defun makemaster-find-end nil
  "Find end of real data, i.e. just before divider."
  (save-excursion
    (makemaster-goto-output-area)
    (search-backward makemaster-output-divider)
    (point)))

;; XXX text properties could substitute for all this crap
(defun makemaster-where-am-i nil
  "Returns (makefile . target) corresponding to current location, if
any. Target may be nil if on a makefile line. Entire return may be nil
if not anywhere near, i.e. in output."
  (if (>= (point) (makemaster-find-end))
      (return nil))
  (let ((makefile
	 (save-excursion
	   (end-of-line)
	   (re-search-backward "^\\([^\t]+\\)$")
	   (match-string 1)))
	(target
	 (save-excursion
	   (beginning-of-line)
	   (if (looking-at "\t[+-?] \\(.*\\)$")
	       (match-string 1)
	     nil))))
    (cons makefile target)))

(provide 'makemaster)
(message "Loading makemaster...done")
